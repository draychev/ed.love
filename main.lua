
-- Minimal MG‑style text editor for Love2D (0.10+)
-- Author: generated by OpenAI, 2025‑06‑24
-- Free‑wheeling style inspired by Kartik Agaram.
--
-- Keys (Ctrl):
--  F/B/N/P : forward, back, next‑line, prev‑line
--  A/E     : line start/end
--  D       : delete char
--  K       : kill to EOL
--  X then (F,S,C) : open file, save, quit
--
-- Line numbers 4‑digit, current line highlighted.
-- Status bar + minibuffer at bottom.

local utf8 = require('utf8')

local buffer      = {""}
local cursor      = {row=1,col=1}
local filename    = nil
local minibuffer  = ""
local mode        = "edit"   -- "edit" or "mini"
local pendingX    = false    -- waiting for 2nd key after C‑x
local ttf         = "fonts/BerkeleyMonoVariable-Regular.ttf"
local font        = love.graphics.newFont(ttf, 14)
love.graphics.setFont(font)
local lh          = font:getHeight()

local function load_file(path)
  buffer = {""}
  local f = io.open(path,"r")
  if f then
    buffer = {}
    for line in f:lines() do table.insert(buffer,line) end
    f:close()
    filename = path
  else
    buffer = {""}
    filename = path
  end
  cursor.row, cursor.col = 1,1
end

local function save_file(path)
  local f = io.open(path,"w")
  if not f then return end
  for _,line in ipairs(buffer) do f:write(line,"\n") end
  f:close()
  filename = path
end

local function clamp(val,min,max) if val<min then return min elseif val>max then return max else return val end end

local function line_count() return #buffer end
local function current_line() return buffer[cursor.row] end

local function move(dx,dy)
  cursor.row = clamp(cursor.row+dy,1,line_count())
  cursor.col = clamp(cursor.col+dx,1,utf8.len(buffer[cursor.row])+1)
end

local function insert_char(ch)
  local line = current_line()
  local bytepos = utf8.offset(line,cursor.col)
  buffer[cursor.row] = line:sub(1,bytepos-1)..ch..line:sub(bytepos)
  move(1,0)
end

local function backspace()
  if cursor.col>1 then
    local line = current_line()
    local b1 = utf8.offset(line,cursor.col)
    local b0 = utf8.offset(line,cursor.col-1)
    buffer[cursor.row] = line:sub(1,b0-1)..line:sub(b1)
    move(-1,0)
  elseif cursor.row>1 then
    local prev_len = utf8.len(buffer[cursor.row-1])
    buffer[cursor.row-1] = buffer[cursor.row-1] .. buffer[cursor.row]
    table.remove(buffer,cursor.row)
    cursor.row = cursor.row-1
    cursor.col = prev_len+1
  end
end

local function delete_char()
  local line = current_line()
  local b0 = utf8.offset(line,cursor.col)
  if b0 and b0<=#line then
    local b1 = utf8.offset(line,cursor.col+1) or (#line+1)
    buffer[cursor.row] = line:sub(1,b0-1)..line:sub(b1)
  elseif cursor.row<line_count() then
    buffer[cursor.row] = line .. buffer[cursor.row+1]
    table.remove(buffer,cursor.row+1)
  end
end

local function kill_to_eol()
  buffer[cursor.row] = current_line():sub(1,utf8.offset(current_line(),cursor.col)-1)
end

function love.textinput(t)
  if mode=="edit" then
    insert_char(t)
  elseif mode=="mini" then
    minibuffer = minibuffer .. t
  end
end

function love.keypressed(key,scancode,isrepeat)
  local ctrl = love.keyboard.isDown("lctrl","rctrl")
  local alt  = love.keyboard.isDown("lalt","ralt")

  if mode=="mini" then
    if key=="return" then
      if pendingX=="open" then load_file(minibuffer)
      elseif pendingX=="save" then save_file(minibuffer) end
      minibuffer="" mode="edit" pendingX=false
    elseif key=="escape" then minibuffer="" mode="edit" pendingX=false
    elseif key=="backspace" then minibuffer=minibuffer:sub(1,#minibuffer-1) end
    return
  end

  -- Ctrl navigation
  if ctrl then
    if key=="f" then move(1,0)
    elseif key=="b" then move(-1,0)
    elseif key=="n" then move(0,1)
    elseif key=="p" then move(0,-1)
    elseif key=="a" then cursor.col=1
    elseif key=="e" then cursor.col=utf8.len(current_line())+1
    elseif key=="d" then delete_char()
    elseif key=="k" then kill_to_eol()
    elseif key=="x" then pendingX=true return
    end
  elseif pendingX and ctrl then
    -- Should not reach
  elseif pendingX then
    if ctrl and key=="f" then mode="mini"; minibuffer=""; pendingX="open"
    elseif ctrl and key=="s" then mode="mini"; minibuffer=""; pendingX="save"
    elseif ctrl and key=="c" then love.event.quit()
    end
    pendingX=false
    return
  end

  if key=="backspace" then backspace()
  elseif key=="return" then
    local line = current_line()
    local head = line:sub(1,utf8.offset(line,cursor.col)-1)
    local tail = line:sub(utf8.offset(line,cursor.col))
    buffer[cursor.row] = head
    table.insert(buffer,cursor.row+1,tail)
    cursor.row = cursor.row+1
    cursor.col = 1
  end
end

function love.draw()
  love.graphics.clear(0.1,0.1,0.1)
  local w,h = love.graphics.getDimensions()
  local lines_visible = math.floor((h-2*lh)/lh)
  local firstline = clamp(cursor.row - math.floor(lines_visible/2),1,math.max(1,line_count()-lines_visible+1))

  for i=0,lines_visible-1 do
    local ln = firstline+i
    if ln>line_count() then break end
    local y = i*lh
    if ln==cursor.row then
      love.graphics.setColor(0.2,0.2,0.4)
      love.graphics.rectangle("fill",0,y,w,lh)
    end
    love.graphics.setColor(0.8,0.8,0.8)
    local lnum = string.format("%04d",ln-1)
    love.graphics.print(lnum.." ",0,y)
    love.graphics.print(buffer[ln], 60, y)
  end

  -- Status bar
  love.graphics.setColor(0.3,0.3,0.3)
  love.graphics.rectangle("fill",0,h-2*lh,w,lh)
  love.graphics.setColor(1,1,1)
  local status = (filename or "(new)").."  Ln "..(cursor.row-1)..", Col "..(cursor.col-1)
  love.graphics.print(status,4,h-2*lh+2)

  -- Minibuffer
  love.graphics.setColor(0,0,0)
  love.graphics.rectangle("fill",0,h-lh,w,lh)
  love.graphics.setColor(1,1,1)
  if mode=="mini" then
    love.graphics.print(minibuffer,4,h-lh+2)
  elseif pendingX then
    love.graphics.print("C-x ",4,h-lh+2)
  end

  -- Cursor
  local cx = 60 + font:getWidth(buffer[cursor.row]:sub(1,utf8.offset(buffer[cursor.row],cursor.col)-1))
  local cy = (cursor.row-firstline)*lh
  love.graphics.setColor(1,1,1)
  love.graphics.rectangle("fill",cx,cy,2,lh)
end
