-- Minimal MG‑style text editor for Love2D (0.10+)
-- Author: generated by OpenAI Codex CLI, 2025‑06‑24
-- Free‑wheeling style inspired by Kartik Agaram.
--
-- Keys (Ctrl):
--  F/B/N/P : forward, back, next‑line, prev‑line
--  A/E     : line start/end
--  D       : delete char
--  K       : kill to EOL
--  X then (F,S,C) : open file, save, quit
--
-- Line numbers 4‑digit, current line highlighted.
-- Status bar + minibuffer at bottom.

-- Freewheeling Apps
require 'app'
require 'live'
require 'keychord'

-- called both in tests and real run
function App.initialize_globals()
  Supported_versions = {'11.5', '11.4', '11.3', '11.2', '11.1', '11.0', '12.0'}  -- put the recommended version first
  Error_message = ''
  Error_count = 0

  -- tests currently mostly clear their own state

  -- blinking cursor
  Cursor_time = 0

  -- for hysteresis in a few places
  Current_time = 0
  Last_focus_time = 0  -- https://love2d.org/forums/viewtopic.php?p=249700
  Last_resize_time = 0
end

---


local utf8        = App.utf8
local buffer      = App.buffer     
local cursor      = App.cursor     
local filename    = App.filename   
local minibuffer  = App.minibuffer 
local mode        = App.mode       
local pendingX    = App.pendingX   
local ttf         = App.ttf        
local font        = App.font       
love.graphics.setFont(font)
local lh          = App.lh         

local function load_file(path)
  buffer = {""}
  local f = io.open(path,"r")
  if f then
    buffer = {}
    for line in f:lines() do table.insert(buffer,line) end
    f:close()
    filename = path
  else
    buffer = {""}
    filename = path
  end
  cursor.row, cursor.col = 1,1
end

local function save_file(path)
  local f = io.open(path,"w")
  if not f then return end
  for _,line in ipairs(buffer) do f:write(line,"\n") end
  f:close()
  filename = path
end

local function delete_char()
  local line = App.current_line()
  local b0 = utf8.offset(line,cursor.col)
  if b0 and b0<=#line then
    local b1 = utf8.offset(line,cursor.col+1) or (#line+1)
    buffer[cursor.row] = line:sub(1,b0-1)..line:sub(b1)
  elseif cursor.row<App.line_count() then
    buffer[cursor.row] = line .. buffer[cursor.row+1]
    table.remove(buffer,cursor.row+1)
  end
end

local function kill_to_eol()
  buffer[cursor.row] = App.current_line():sub(1,utf8.offset(current_line(),cursor.col)-1)
end


--- stuff from akkartik --------------------
-- called only for real run
function App.initialize(arg, unfiltered_arg)
  Arg, Unfiltered_arg = arg, unfiltered_arg
  love.keyboard.setKeyRepeat(true)

  Editor_state = nil  -- not used outside editor tests

  love.graphics.setBackgroundColor(1,1,1)

  if love.filesystem.getInfo('config') then
    load_settings()
  else
    initialize_default_settings()
  end



  -- app-specific stuff
  -- keep a few blank lines around: https://merveilles.town/@akkartik/110084833821965708
  love.window.setTitle('broadsheet.love')



  if on.initialize then on.initialize(arg, unfiltered_arg) end

  if rawget(_G, 'jit') then
    jit.off()
    jit.flush()
  end
end

function initialize_default_settings()
  local font_height = 20
  love.graphics.setFont(love.graphics.newFont(font_height))
  initialize_window_geometry()
end

function initialize_window_geometry()
  -- Initialize window width/height and make window resizable.
  --
  -- I get tempted to have opinions about window dimensions here, but they're
  -- non-portable:
  --  - maximizing doesn't work on mobile and messes things up
  --  - maximizing keeps the title bar on screen in Linux, but off screen on
  --    Windows. And there's no way to get the height of the title bar.
  -- It seems more robust to just follow LÖVE's default window size until
  -- someone overrides it.
  App.screen.width, App.screen.height, App.screen.flags = App.screen.size()
  App.screen.flags.resizable = true
  App.screen.resize(App.screen.width, App.screen.height, App.screen.flags)
end




--- akkartik -- app-dots

function App.resize(w,h)
--?   print(("Window resized to width: %d and height: %d."):format(w, h))
  App.screen.width, App.screen.height = w, h
  -- some hysteresis while resizing
  if Current_time < Last_resize_time + 0.1 then
    return
  end
  Last_resize_time = Current_time
  if on.resize then on.resize(w,h) end
end

function App.filedropped(file)
  if on.file_drop then on.file_drop(file) end
end

function App.draw(utf8, buffer, lh, cursor)
  -- print("DEBUG(main.App.draw): drawing")
  if on.draw then on.draw(App) end
end

function App.update(dt)
  Current_time = Current_time + dt
  -- some hysteresis while resizing
  if Current_time < Last_resize_time + 0.1 then
    return
  end
  Cursor_time = Cursor_time + dt
  live.update(dt)
  if on.update then on.update(dt) end
end

function App.mousepressed(x,y, mouse_button, is_touch, presses)
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  love.keyboard.setTextInput(true)  -- bring up keyboard on touch screen
  if on.mouse_press then on.mouse_press(x,y, mouse_button, is_touch, presses) end
end

function App.mousereleased(x,y, mouse_button, is_touch, presses)
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.mouse_release then on.mouse_release(x,y, mouse_button, is_touch, presses) end
end

function App.mousemoved(x,y, dx,dy, istouch)
  if on.mouse_move then on.mouse_move(x,y, dx,dy, istouch) end
end

function App.wheelmoved(dx,dy)
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.mouse_wheel_move then on.mouse_wheel_move(dx,dy) end
end

function App.mousefocus(in_focus)
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.mouse_focus then on.mouse_focus(in_focus) end
end

function App.focus(in_focus)
  if in_focus then
    Last_focus_time = Current_time
  end
  if in_focus then
    love.graphics.setBackgroundColor(1,1,1)
  else
    love.graphics.setBackgroundColor(0.8,0.8,0.8)
  end
  if on.focus then on.focus(in_focus) end
end

-- App.keypressed is defined in keychord.lua

function App.keychord_press(chord, key, scancode, is_repeat)
  -- print("DEBUG(main): App.keychord_press chord=" .. chord .. ", key=" .. key .. ", scancode=" .. scancode .. "is_repeat=" .. tostring(is_repeat))
  -- ignore events for some time after window in focus (mostly alt-tab)
  if Current_time < Last_focus_time + 0.01 then
    return
  end
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.keychord_press then on.keychord_press(chord, key, scancode, is_repeat) end
end

function App.textinput(t)
   print("DEBUG(main.App.textinput): t=" .. t)
  -- ignore events for some time after window in focus (mostly alt-tab)
  if Current_time < Last_focus_time + 0.01 then
    return
  end
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.text_input then on.text_input(t, App) end
end

function App.keyreleased(key, scancode)
  -- ignore events for some time after window in focus (mostly alt-tab)
  if Current_time < Last_focus_time + 0.01 then
    return
  end
  Cursor_time = 0  -- ensure cursor is visible immediately after it moves
  if on.key_release then on.key_release(key, scancode) end
end

-- plumb all other handlers through to on.*
for handler_name in pairs(love.handlers) do
  if App[handler_name] == nil then
    App[handler_name] = function(...)
      if on[handler_name] then on[handler_name](...) end
    end
  end
end
