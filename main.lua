-- Minimal MG‑style text editor for Love2D (0.10+)
-- Author: generated by OpenAI Codex CLI, 2025‑06‑24
-- Free‑wheeling style inspired by Kartik Agaram.
--
-- Keys (Ctrl):
--  F/B/N/P : forward, back, next‑line, prev‑line
--  A/E     : line start/end
--  D       : delete char
--  K       : kill to EOL
--  X then (F,S,C) : open file, save, quit
--
-- Line numbers 4‑digit, current line highlighted.
-- Status bar + minibuffer at bottom.
-- Freewheeling Apps
require 'app'
require 'debug'
require 'live'
require 'keychord'
nativefs = require 'nativefs'
require 'freewheel'

-- main entrypoint for LÖVE
--
-- Most apps can just use the default shown in https://love2d.org/wiki/love.run,
-- but we need to override it to:
--   * recover from errors (by sending them to the driver and waiting for a command)
--   * run all tests (functions starting with 'test_') on startup, and
--   * save some state that makes it possible to switch between the main app
--     and a source editor, while giving each the illusion of complete
--     control.
local Keys_down = {}
function love.run()
    Version, Major_version = App.love_version()
    freewheel.snapshot_love()
    live.load()
    -- have LÖVE delegate all handlers to App if they exist
    -- make sure to late-bind handlers like LÖVE's defaults do
    for name in pairs(love.handlers) do
        if App[name] then
            -- love.keyboard.isDown doesn't work on Android - emulate using
            -- keypressed and keyreleased events
            if name == 'keypressed' then
                love.handlers[name] = function(key, scancode, isrepeat)
                    Keys_down[key] = true
                    return App.keypressed(key, scancode, isrepeat)
                end
            elseif name == 'keyreleased' then
                love.handlers[name] = function(key, scancode)
                    Keys_down[key] = nil
                    return App.keyreleased(key, scancode)
                end
            else
                love.handlers[name] = function(...)
                    App[name](...)
                end
            end
        end
    end

    -- Stash initial state of App (right after loading files) for tests
    if App_for_tests == nil then
        App_for_tests = {}
        for k, v in pairs(App) do App_for_tests[k] = v end
        -- there's one nested table
        App_for_tests.screen = {}
        for k, v in pairs(App.screen) do App_for_tests.screen[k] = v end
    end
    -- Mutate App for the real app
    -- disable test methods
    App.screen.init = nil
    App.filesystem = nil
    App.time = nil
    App.run_after_textinput = nil
    App.run_after_keychord = nil
    App.keypress = nil
    App.keyrelease = nil
    App.run_after_mouse_click = nil
    App.run_after_mouse_press = nil
    App.run_after_mouse_release = nil
    App.fake_keys_pressed = nil
    App.fake_key_press = nil
    App.fake_key_release = nil
    App.fake_mouse_state = nil
    App.fake_mouse_press = nil
    App.fake_mouse_release = nil
    -- other methods dispatch to real hardware
    App.screen.resize = love.window.setMode
    App.screen.size = love.window.getMode
    App.screen.move = love.window.setPosition
    App.screen.position = love.window.getPosition
    App.screen.print = love.graphics.print
    App.open_for_reading = function(filename)
        local result = nativefs.newFile(filename)
        local ok, err = result:open('r')
        if ok then
            return result
        else
            return ok, err
        end
    end
    App.read_file = function(path)
        if not is_absolute_path(path) then
            return --[[status]] false,
                                'Please use an unambiguous absolute path.'
        end
        local f, err = App.open_for_reading(path)
        if err then return --[[status]] false, err end
        local contents = f:read()
        f:close()
        return contents
    end

    App.open_for_writing = function(filename)
        DEBUG("main.App.open_for_writing", "filename=" .. filename)
        local result = nativefs.newFile(filename)
        local ok, err = result:open('w')
        if ok then
            return result
        else
            return ok, err
        end
    end
    App.write_file = function(path, contents)
        if not is_absolute_path(path) then
            return --[[status]] false,
                                'Please use an unambiguous absolute path.'
        end
        local f, err = App.open_for_writing(path)
        if err then return --[[status]] false, err end
        f:write(contents)
        f:close()
        return --[[status]] true
    end
    App.files = nativefs.getDirectoryItems
    App.file_info = nativefs.getInfo
    App.mkdir = nativefs.createDirectory
    App.remove = nativefs.remove
    App.source_dir = love.filesystem.getSource() .. '/' -- '/' should work even on Windows
    App.current_dir = nativefs.getWorkingDirectory() .. '/'
    App.save_dir = love.filesystem.getSaveDirectory() .. '/'
    App.get_time = love.timer.getTime
    App.get_clipboard = love.system.getClipboardText
    App.set_clipboard = love.system.setClipboardText
    App.key_down = function(key) return Keys_down[key] end
    App.mouse_move = love.mouse.setPosition
    App.mouse_down = love.mouse.isDown
    App.mouse_x = love.mouse.getX
    App.mouse_y = love.mouse.getY

    -- Tests always run at the start.
    Test_errors = {}
    App.run_tests(record_error)
    -- if we encounter an error, wait for a fix
    if #Test_errors > 0 then
        local error_message = 'There were test failures:\n\n' ..
                                  table.concat(Test_errors, '\n')
        print(error_message)
        live.send_run_time_error_to_driver(error_message)
        local current_time, previous_read = 0, 0
        while true do
            if love.event then
                love.event.pump()
                for name, a, b, c, d, e, f in love.event.poll() do
                    if name == 'quit' then os.exit(1) end
                end
            end

            local dt = love.timer.step()
            current_time = current_time + dt
            if current_time - previous_read > 0.1 then
                local buf = live.receive_from_driver()
                if buf then
                    local maybe_mutated = live.run(buf)
                    if maybe_mutated then
                        Test_errors = {}
                        App.run_tests(record_error)
                        if #Test_errors == 0 then break end
                        error_message = 'There were test failures:\n\n' ..
                                            table.concat(Test_errors, '\n')
                        print(error_message)
                        live.send_run_time_error_to_driver(error_message)
                    end
                end
            end

            love.graphics.origin()
            love.graphics.clear(0, 0, 1)
            love.graphics.setColor(1, 1, 1)
            love.graphics.printf(error_message, 40, 40, 600)
            love.graphics.present()

            love.timer.sleep(0.001)
        end
    end

    App.initialize_globals()
    xpcall(function() App.initialize(love.arg.parseGameArguments(arg), arg) end,
           live.handle_initialization_error)

    love.timer.step()

    -- protect against runtime errors
    return function()
        local status, result = xpcall(App.run_frame, live.handle_error)
        return result
    end
end
